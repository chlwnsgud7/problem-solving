{
    "template": {
        "scope": "cpp",
        "prefix": ["tmp_sni"],
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef vector<int> vi;",
            "typedef vector<vi> vvi;",
            "typedef vector<bool> vb;",
            "typedef vector<vb> vvb;",
            "typedef vector<string> vs;",
            "typedef long long int ll;",
            "typedef unsigned long long int ull;",
            "typedef pair<int, int> pii;",
            "typedef vector<ll> vll;",
            "typedef vector<vll> vvll;",
            "typedef vector<pii> vpii;",
            "typedef vector<vpii> vvpii;",
            "",
            "inline bool valid(int x, int n) {",
            "    return 0 <= x && x < n;",
            "}",
            "",
            "int dx[] = {0, 0, 1, -1};",
            "int dy[] = {1, -1, 0, 0};",
            "",
            "template <typename T>",
            "inline T pop(queue<T>& q) {",
            "    T front = q.front();",
            "    q.pop();",
            "    return front;",
            "}",
            "",
            "template <typename T>",
            "inline T gcd(T a, T b) {",
            "    for (; b; a %= b, swap(a, b));",
            "    return a; ",
            "}",
            "",
            "template <typename T>",
            "tuple<T, T, T> xgcd(T a, T b) {",
            "    if (b == 0) return {1, 0, a};",
            "    T x, y, g;",
            "    tie(x, y, g) = xgcd(b, a%b);",
            "    return {y, x-(a/b)*y, g};",
            "}",
            "",
            "int main() {",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(NULL); cout.tie(NULL);",
            "}"
        ],
        "description": "PS 템플릿. 빈 코드에 사용할 것."
    },
    "geometry": {
        "scope": "cpp",
        "prefix": ["geo_sni"],
        "body": [
            "typedef pair<ll, ll> pll;",
            "",
            "#define x first",
            "#define y second",
            "",
            "pll operator-(pll& A, pll& B) {",
            "    return {A.x-B.x, A.y-B.y};",
            "}",
            "",
            "ll ccw(pll& A, pll& B, pll& C) {",
            "    pll a = B - A;",
            "    pll b = C - B;",
            "    ",
            "    ll prod = (ll)a.x*b.y - (ll)a.y*b.x;",
            "    if (prod) return prod / abs(prod);",
            "    else return 0;",
            "}",
            "",
            "bool cross(pll& A, pll& B, pll& C, pll& D) {",
            "    if (A == C || A == D || B == C || B == D) return 1;",
            "    ",
            "    ll abc = ccw(A, B, C);",
            "    ll abd = ccw(A, B, D);",
            "    ll cda = ccw(C, D, A);",
            "    ll cdb = ccw(C, D, B);",
            "    ",
            "    if (abc*abd == 1) return 0;",
            "    if (cda*cdb == 1) return 0;",
            "    ",
            "    if (abc == 0 && abd == 0) {",
            "        if (A.x != B.x) {",
            "            ll x1 = min(A.x, B.x);",
            "            ll x2 = max(A.x, B.x);",
            "            ll x3 = min(C.x, D.x);",
            "            ll x4 = max(C.x, D.x);",
            "            ",
            "            if (x2 < x3 || x1 > x4) return 0;",
            "        }",
            "        else {",
            "            ll y1 = min(A.y, B.y);",
            "            ll y2 = max(A.y, B.y);",
            "            ll y3 = min(C.y, D.y);",
            "            ll y4 = max(C.y, D.y);",
            "            ",
            "            if (y2 < y3 || y1 > y4) return 0;",
            "        }",
            "    }",
            "    ",
            "    return 1;",
            "}"
        ],
        "description": "기하 스니펫. 전역에 사용할 것."
    },
    "convex_hull": {
        "scope": "cpp",
        "prefix": ["cvxh_sni"],
        "body": [
            "vpll convex_hull(vpll points) {",
            "    if (points.size() == 1) return points;",
            "    ",
            "    sort(points.begin(), points.end());",
            "    vpll up; up.reserve(points.size());",
            "    for (pll& p : points) {",
            "        up.push_back(p);",
            "        while (up.size() >= 3) {",
            "            auto a = up.end() - 3;",
            "            auto b = up.end() - 2;",
            "            auto c = up.end() - 1;",
            "            if (ccw(*a, *b, *c) == -1) break;",
            "            up.erase(b);",
            "        }",
            "    }",
            "    ",
            "    reverse(points.begin(), points.end());",
            "    vpll down; down.reserve(points.size());",
            "    for (pll& p : points) {",
            "        down.push_back(p);",
            "        while (down.size() >= 3) {",
            "            auto a = down.end() - 3;",
            "            auto b = down.end() - 2;",
            "            auto c = down.end() - 1;",
            "            if (ccw(*a, *b, *c) == -1) break;",
            "            down.erase(b);",
            "        }",
            "    }",
            "    ",
            "    vpll cvxh; cvxh.reserve(points.size());",
            "    cvxh.insert(cvxh.end(), up.begin(), up.end()-1);",
            "    cvxh.insert(cvxh.end(), down.begin(), down.end()-1);",
            "    return cvxh;",
            "}"
        ],
        "description": "컨벡스 헐 스니펫. geo_sni 사용 후 전역에 사용할 것."
    },
    "CHT": {
        "scope": "cpp",
        "prefix": ["cht_sni"],
        "body": [
            "struct line {",
            "    ll a, b; ",
            "    line(ll a, ll b): a(a), b(b) {}",
            "};",
            "vector<line> lines;",
            "",
            "auto cx = [] (const line& l, const line& m) -> double {",
            "    return 1.0 * (m.b-l.b) / (l.a-m.a);",
            "};",
            "",
            "auto insert = [&lines, &cx] (const line& v) -> void {",
            "    while (lines.size() >= 2 && cx(*(lines.rbegin()+1), *lines.rbegin()) > cx(*lines.rbegin(), v))  {",
            "        lines.pop_back();",
            "    }",
            "    lines.push_back(v);",
            "};",
            "",
            "auto find = [&lines, &cx] (ll x) -> ll {",
            "    ll lo = 0;",
            "    ll hi = lines.size()-1;",
            "",
            "    while (lo < hi) {",
            "        ll mid = (lo + hi) / 2;",
            "        if (cx(lines[mid], lines[mid+1]) <= x) lo = mid+1;",
            "        else hi = mid;",
            "    }",
            "    return lines[lo].a * x + lines[lo].b;",
            "};"
        ],
        "description": "CHT(컨벡스 헐 트릭) 스니펫. 사용제한 없음."
    },
    "FFT": {
        "scope": "cpp",
        "prefix": ["fft_sni"],
        "body": [
            "using cpx = complex<double>;",
            "using vec = vector<cpx>;",
            "const double pi = 3.14159265358979;",
            "",
            "function<vec(vec, vec)> mul = [pi] (vec a, vec b) -> vec {",
            "    function<void(vec&, cpx)> FFT = [&FFT](vec& f, cpx w) -> void {",
            "        int n = f.size();",
            "        if (n == 1) return;",
            "",
            "        vec even(n>>1), odd(n>>1);",
            "        for (int i = 0; i < n; i++) {",
            "            if (i & 1) odd[i>>1] = f[i];",
            "            else even[i>>1] = f[i];",
            "        }",
            "        FFT(even, w*w); FFT(odd, w*w);",
            "        cpx wp(1, 0);",
            "        for (int i = 0; i < n/2; i++) {",
            "            f[i] = even[i] + wp*odd[i];",
            "            f[i+n/2] = even[i] - wp*odd[i];",
            "            wp = wp * w;",
            "        }",
            "    };",
            "",
            "    int n = 1;",
            "    while (n <= a.size() || n <= b.size()) n <<= 1;",
            "    n <<= 1;",
            "    a.resize(n); b.resize(n); vec c(n);",
            "",
            "    cpx w(cos(2*pi/n), sin(2*pi/n));",
            "    FFT(a, w); FFT(b, w);",
            "    for (int i = 0; i < n; i++) c[i] = a[i] * b[i];",
            "",
            "    FFT(c, cpx(w.real(), -w.imag()));",
            "    for (int i = 0; i < n; i++) {",
            "        c[i] /= cpx(n, 0);",
            "        /* c[i] = cpx(round(c[i].real()), round(c[i].imag())); /* 정수 결과 필요시 */",
            "    }",
            "",
            "    return c;",
            "};"
        ],
        "description": "FFT(고속 푸리에 변환) 스니펫. 사용제한 없음."
    }
}